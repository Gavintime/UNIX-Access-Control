#!/usr/bin/env python3

import sys
from typing import List, Dict, Set


class AccessController():

    def __init__(self):

        self._current_user: str             = None
        self._root_created: bool            = False
        self._groups: Dict[str, Set[str]]   = {}
        self._audit_fname: str              = "audit.txt"
        self._accounts_fname: str           = "accounts.txt"

        # create special files (overwrite)
        try:
            with open(self._accounts_fname, 'w'):
                pass
            with open(self._audit_fname, 'w'):
                pass
        except IOError:
            sys.exit("IO Error: Unable to create special files, exiting...")

    # add given user, erroring if user already exists
    def useradd(self, username: str, password: str):

        # make sure root is the first user created
        if not self._root_created and username != 'root':
            self._log("Error: First command must create root user.")
            return

        # only allow command while logged out if root not made yet
        if self._root_created and self._current_user is None:
            self._log("Error: You Must be logged in to run useradd.")
            return

        # make sure user doesn't exist yet
        if self._user_exists(username):
            self._log(f"Error: User {username} already exists.")
            return

        if '/' in username or ':' in username:
            self._log("Username cannot contain a forward slash (/) or colon (:).")
            return

        # add user to accounts file
        try:
            with open(self._accounts_fname, 'a') as accounts_file:
                accounts_file.write(f"{username} {password}\n")
        except IOError:
            self._log("IO Error: Unable to add user to accounts file.")
            return

        if username == 'root':
            self._root_created = True
        self._log(f"User {username} created")

    def login(self, username: str, password: str):

        # don't login if someone is already logged in
        if self._current_user is not None:
            self._log("Error: Cannot login, a user is currently logged in")
            return

        # read in usernames and passwords
        user_info = []
        try:
            with open(self._accounts_fname, 'r') as accounts_file:
                for line in accounts_file:
                    user_info.append(line.split()[0:2])
        except IOError:
            self._log("IO Error: Unable to read accounts file.")
            return

        if [username, password] in user_info:
            self._current_user = username
            self._log(f"User {username} logged in")
        else:
            self._log("Username or password is incorrect. Login Failed.")

    def groupadd(self, groupname: str):

        # auth checking
        if self._current_user != 'root':
            self._log("Only root can run this command.")
            return

        if groupname == 'nil':
            self._log("The name nil is not a valid groupname.")
            return

        if '/' in groupname or ':' in groupname:
            self._log("Groupname cannot contain a forward slash (/) or colon (:).")
            return

        # check if group exists
        if groupname in self._groups:
            self._log(f"Group {groupname} already exists.")
            return

        # create empty group
        self._groups[groupname] = {}
        self._log(f"Group {groupname} created")

    # logs to stdout and audit.txt
    def _log(self, message: str):

        print(message)
        try:
            with open(self._audit_fname, 'a') as audit_file:
                audit_file.write(message + '\n')
        except IOError:
            sys.exit("Unable append log to audit.txt, exiting...")

    # returns true if user is present, false otherwise
    # helper function for useradd
    def _user_exists(self, username: str) -> bool:

        usernames = []
        # read in user info
        try:
            with open(self._accounts_fname, 'r') as accounts_file:
                for line in accounts_file:
                    usernames.append(line.split()[0])
        except IOError:
            self._log("IO Error: Unable to read accounts file.")
            return True

        return username in usernames


# return list of instructions from given file
# instructions are in the form of a list of words
def read_instruction_file(filename: str) -> List[List[str]]:

    instructions = []
    # read in instructions, removing newline char
    try:
        with open(filename, 'r') as instruction_file:
            for line in instruction_file:
                instructions.append(line[:-1].split())
        return instructions
    except IOError:
        sys.exit("Unable to open instruction file, exiting...")


# reads the instruction file and parses commands to be sent to the Access Controller
def main():

    # get instructions
    if len(sys.argv) != 2:
        sys.exit("Wrong number of arguments, expecting a single filename, exiting...")
    filename = sys.argv[1]
    instructions = read_instruction_file(filename)

    # create Access Control manager
    acm = AccessController()

    # Start processing instructions
    for inst in instructions:

        if inst[0] == 'useradd':
            acm.useradd(inst[1], inst[2])

        elif inst[0] == 'login':
            acm.login(inst[1], inst[2])

        elif inst[0] == 'logout':
            acm.logout()

        elif inst[0] == 'groupadd':
            acm.groupadd(inst[1])

        elif inst[0] == 'usergrp':
            acm.usergrp(inst[1], inst[2])

        elif inst[0] == 'mkfile':
            acm.mkfile(inst[1])

        elif inst[0] == 'chmod':
            acm.chmod(inst[1], inst[2], inst[3], inst[4])

        elif inst[0] == 'chown':
            acm.chown(inst[1], inst[2])

        elif inst[0] == 'chgrp':
            acm.chgrp(inst[1], inst[2])

        elif inst[0] == 'read':
            acm.read(inst[1])

        elif inst[0] == 'write':
            acm.write(inst[1], inst[2])

        elif inst[0] == 'execute':
            acm.execute(inst[1])

        elif inst[0] == 'ls':
            acm.ls(inst[1])

        elif inst[0] == 'end':
            acm.end()

        # command does not exist
        else:
            pass


if __name__ == '__main__':
    main()
